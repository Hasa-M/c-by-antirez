<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BST Recursive Free — Step by Step</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=DM+Sans:wght@400;500;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --bg: #0e1117;
    --surface: #161b22;
    --border: #30363d;
    --text: #e6edf3;
    --text-dim: #8b949e;
    --green: #3fb950;
    --green-bg: rgba(63, 185, 80, 0.1);
    --red: #f85149;
    --red-bg: rgba(248, 81, 73, 0.12);
    --yellow: #d29922;
    --yellow-bg: rgba(210, 153, 34, 0.1);
    --blue: #58a6ff;
    --blue-bg: rgba(88, 166, 255, 0.1);
    --purple: #bc8cff;
  }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'DM Sans', sans-serif;
    min-height: 100vh;
    padding: 2rem;
  }

  h1 {
    font-family: 'JetBrains Mono', monospace;
    font-size: 1.5rem;
    font-weight: 700;
    margin-bottom: 0.25rem;
    color: var(--text);
  }

  .subtitle {
    color: var(--text-dim);
    font-size: 0.9rem;
    margin-bottom: 2rem;
  }

  .layout {
    display: grid;
    grid-template-columns: 1fr 320px;
    gap: 2rem;
    max-width: 1100px;
    margin: 0 auto;
  }

  /* Tree visualization */
  .tree-panel {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 1.5rem;
    min-height: 460px;
    position: relative;
  }

  .tree-panel h2 {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.85rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.08em;
    margin-bottom: 1rem;
  }

  svg.tree-svg {
    width: 100%;
    height: 380px;
    display: block;
  }

  .edge {
    stroke: var(--border);
    stroke-width: 2;
    transition: stroke 0.3s, opacity 0.3s;
  }
  .edge.freed { stroke: var(--red); opacity: 0.25; stroke-dasharray: 5 5; }
  .edge.active { stroke: var(--yellow); stroke-width: 2.5; }

  .node-group { cursor: default; }

  .node-circle {
    r: 22;
    fill: var(--surface);
    stroke: var(--border);
    stroke-width: 2;
    transition: fill 0.3s, stroke 0.3s, opacity 0.3s;
  }
  .node-circle.active { stroke: var(--yellow); fill: var(--yellow-bg); stroke-width: 2.5; }
  .node-circle.freed { stroke: var(--red); fill: var(--red-bg); opacity: 0.4; stroke-dasharray: 4 3; }
  .node-circle.safe { stroke: var(--green); fill: var(--green-bg); }

  .node-label {
    fill: var(--text);
    font-family: 'JetBrains Mono', monospace;
    font-size: 13px;
    font-weight: 600;
    text-anchor: middle;
    dominant-baseline: central;
    transition: fill 0.3s, opacity 0.3s;
  }
  .node-label.freed { fill: var(--red); opacity: 0.4; text-decoration: line-through; }

  .node-order {
    fill: var(--green);
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    font-weight: 700;
    text-anchor: middle;
    opacity: 0;
    transition: opacity 0.3s;
  }
  .node-order.visible { opacity: 1; }

  /* Right panel */
  .right-panel {
    display: flex;
    flex-direction: column;
    gap: 1.25rem;
  }

  /* Call stack */
  .stack-panel {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 1.25rem;
  }

  .stack-panel h2 {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.85rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.08em;
    margin-bottom: 0.75rem;
  }

  .stack-frames {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .stack-frame {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.78rem;
    padding: 6px 10px;
    border-radius: 6px;
    background: var(--blue-bg);
    border: 1px solid rgba(88, 166, 255, 0.2);
    color: var(--blue);
    animation: slideIn 0.2s ease;
  }
  .stack-frame.free-call {
    background: var(--red-bg);
    border-color: rgba(248, 81, 73, 0.25);
    color: var(--red);
  }
  .stack-frame.null-call {
    background: rgba(139, 148, 158, 0.08);
    border-color: rgba(139, 148, 158, 0.15);
    color: var(--text-dim);
  }

  @keyframes slideIn {
    from { opacity: 0; transform: translateX(-8px); }
    to { opacity: 1; transform: translateX(0); }
  }

  .stack-empty {
    color: var(--text-dim);
    font-size: 0.8rem;
    font-style: italic;
  }

  /* Log */
  .log-panel {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 1.25rem;
    flex: 1;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  .log-panel h2 {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.85rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.08em;
    margin-bottom: 0.75rem;
  }

  .log-entries {
    flex: 1;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 3px;
    max-height: 220px;
  }

  .log-entry {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.72rem;
    padding: 4px 8px;
    border-radius: 4px;
    animation: slideIn 0.15s ease;
  }
  .log-entry.recurse { color: var(--blue); }
  .log-entry.base { color: var(--text-dim); }
  .log-entry.free { color: var(--red); background: var(--red-bg); }
  .log-entry.done { color: var(--green); }

  /* Controls */
  .controls {
    display: flex;
    gap: 0.75rem;
    align-items: center;
    margin-bottom: 1.5rem;
    flex-wrap: wrap;
  }

  button {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.82rem;
    font-weight: 600;
    padding: 8px 18px;
    border-radius: 8px;
    border: 1px solid var(--border);
    background: var(--surface);
    color: var(--text);
    cursor: pointer;
    transition: all 0.15s;
  }
  button:hover { border-color: var(--blue); color: var(--blue); }
  button:disabled { opacity: 0.35; cursor: not-allowed; }
  button.primary {
    background: var(--blue);
    border-color: var(--blue);
    color: #0e1117;
  }
  button.primary:hover { background: #79b8ff; }
  button.primary:disabled { background: var(--blue); opacity: 0.35; }

  .step-counter {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.82rem;
    color: var(--text-dim);
    margin-left: auto;
  }

  .speed-control {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.78rem;
    color: var(--text-dim);
    font-family: 'JetBrains Mono', monospace;
  }

  .speed-control input[type="range"] {
    width: 70px;
    accent-color: var(--blue);
  }

  /* Description */
  .description-box {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 1.25rem;
    margin-bottom: 1.5rem;
    font-size: 0.88rem;
    line-height: 1.6;
    color: var(--text-dim);
    min-height: 56px;
    display: flex;
    align-items: center;
  }
  .description-box .highlight { color: var(--text); font-weight: 500; }
  .description-box .val { color: var(--yellow); font-family: 'JetBrains Mono', monospace; font-weight: 600; }
  .description-box .freed-text { color: var(--red); font-weight: 600; }
  .description-box .null-text { color: var(--text-dim); font-style: italic; }

  .legend {
    display: flex;
    gap: 1.25rem;
    margin-top: 1rem;
    flex-wrap: wrap;
  }
  .legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.75rem;
    color: var(--text-dim);
    font-family: 'JetBrains Mono', monospace;
  }
  .legend-dot {
    width: 12px; height: 12px;
    border-radius: 50%;
    border: 2px solid;
  }
  .legend-dot.active { border-color: var(--yellow); background: var(--yellow-bg); }
  .legend-dot.freed { border-color: var(--red); background: var(--red-bg); opacity: 0.6; }
  .legend-dot.unvisited { border-color: var(--border); background: var(--surface); }

  @media (max-width: 800px) {
    .layout { grid-template-columns: 1fr; }
    body { padding: 1rem; }
  }
</style>
</head>
<body>

<h1>free_tree() — Post-Order Traversal</h1>
<p class="subtitle">Watch how recursive free safely deallocates a BST bottom-up</p>

<div class="controls">
  <button class="primary" id="btn-next">Next Step →</button>
  <button id="btn-auto">▶ Auto Play</button>
  <button id="btn-reset">Reset</button>
  <div class="speed-control">
    <label>Speed</label>
    <input type="range" id="speed" min="1" max="5" value="3">
  </div>
  <span class="step-counter" id="step-counter"></span>
</div>

<div class="description-box" id="description">
  Press <span class="highlight">Next Step</span> to begin freeing the tree starting from root <span class="val">20</span>. The algorithm visits left subtree → right subtree → then frees the node (post-order).
</div>

<div class="layout">
  <div class="tree-panel">
    <h2>Binary Search Tree</h2>
    <svg class="tree-svg" id="tree-svg"></svg>
    <div class="legend">
      <div class="legend-item"><div class="legend-dot active"></div>Currently visiting</div>
      <div class="legend-item"><div class="legend-dot freed"></div>Freed</div>
      <div class="legend-item"><div class="legend-dot unvisited"></div>Not yet visited</div>
    </div>
  </div>

  <div class="right-panel">
    <div class="stack-panel">
      <h2>Call Stack</h2>
      <div class="stack-frames" id="stack-frames">
        <span class="stack-empty">Empty — not started</span>
      </div>
    </div>

    <div class="log-panel">
      <h2>Execution Log</h2>
      <div class="log-entries" id="log-entries"></div>
    </div>
  </div>
</div>

<script>
// BST structure matching the user's tree
// Tree:       20
//           /    \
//         10      100
//        /  \     /
//       5   20  40
//           /   /
//         20   33

const nodes = [
  { id: 0, val: 20, left: 1, right: 2 },   // root
  { id: 1, val: 10, left: 3, right: 4 },   // 10
  { id: 2, val: 100, left: 5, right: -1 },  // 100
  { id: 3, val: 5, left: -1, right: -1 },   // 5
  { id: 4, val: 20, left: 6, right: -1 },   // 20 (dup)
  { id: 5, val: 40, left: 7, right: -1 },   // 40
  { id: 6, val: 20, left: -1, right: -1 },  // 20 (dup)
  { id: 7, val: 33, left: -1, right: -1 },  // 33
];

// Layout positions for SVG (manually positioned for clarity)
const svgW = 700, svgH = 380;
const positions = {
  0: { x: 350, y: 45 },
  1: { x: 175, y: 120 },
  2: { x: 525, y: 120 },
  3: { x: 100, y: 200 },
  4: { x: 250, y: 200 },
  5: { x: 460, y: 200 },
  6: { x: 200, y: 280 },
  7: { x: 400, y: 280 },
};

const edges = [
  [0,1],[0,2],[1,3],[1,4],[2,5],[4,6],[5,7]
];

// Generate all steps via simulated post-order traversal
function generateSteps() {
  const steps = [];
  const freedSet = new Set();
  let freeOrder = 1;

  function rec(nodeId, depth, parentDesc) {
    const indent = "  ".repeat(depth);
    if (nodeId === -1) {
      steps.push({
        type: 'base_case',
        activeNode: -1,
        stack_push: `${indent}free_tree(NULL)`,
        stack_pop: true,
        log: { text: `${indent}→ NULL, return`, cls: 'base' },
        desc: `<span class="null-text">Reached a NULL pointer — base case, return immediately.</span>`,
        freed: new Set(freedSet),
        freeOrders: Object.assign({}, currentOrders),
      });
      return;
    }

    const n = nodes[nodeId];
    // Step: entering this node, about to go left
    steps.push({
      type: 'enter',
      activeNode: nodeId,
      stack_push: `${indent}free_tree(${n.val}) [id:${nodeId}]`,
      log: { text: `${indent}→ free_tree(${n.val})`, cls: 'recurse' },
      desc: `Entering node <span class="val">${n.val}</span>. First, recurse into the <span class="highlight">left</span> subtree.`,
      freed: new Set(freedSet),
      freeOrders: Object.assign({}, currentOrders),
    });

    // Recurse left
    rec(n.left, depth + 1, n.val);

    // Back from left, about to go right
    steps.push({
      type: 'mid',
      activeNode: nodeId,
      log: { text: `${indent}  ← left done, go right`, cls: 'recurse' },
      desc: `Back at <span class="val">${n.val}</span>. Left subtree fully freed. Now recurse into the <span class="highlight">right</span> subtree.`,
      freed: new Set(freedSet),
      freeOrders: Object.assign({}, currentOrders),
    });

    // Recurse right
    rec(n.right, depth + 1, n.val);

    // Free this node
    freedSet.add(nodeId);
    currentOrders[nodeId] = freeOrder++;
    steps.push({
      type: 'free',
      activeNode: nodeId,
      freeNode: nodeId,
      stack_pop: true,
      log: { text: `${indent}  ✕ free(${n.val})  — #${currentOrders[nodeId]}`, cls: 'free' },
      desc: `Both children handled. Now it's safe to <span class="freed-text">free(${n.val})</span> — free order <span class="freed-text">#${currentOrders[nodeId]}</span>.`,
      freed: new Set(freedSet),
      freeOrders: Object.assign({}, currentOrders),
    });
  }

  var currentOrders = {};
  rec(0, 0, 'main');

  steps.push({
    type: 'done',
    activeNode: -1,
    log: { text: '✓ All nodes freed!', cls: 'done' },
    desc: `<span class="highlight" style="color: var(--green);">Done!</span> All 8 nodes freed safely. Children are always freed before their parents — no dangling pointer access.`,
    freed: new Set(freedSet),
    freeOrders: Object.assign({}, currentOrders),
  });

  return steps;
}

const steps = generateSteps();
let currentStep = -1;
let autoInterval = null;

// Draw SVG tree
function drawTree() {
  const svg = document.getElementById('tree-svg');
  svg.setAttribute('viewBox', `0 0 ${svgW} ${svgH}`);
  let html = '';

  // Edges
  for (const [from, to] of edges) {
    const p1 = positions[from], p2 = positions[to];
    html += `<line class="edge" id="edge-${from}-${to}" x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}"/>`;
  }

  // Nodes
  for (const n of nodes) {
    const p = positions[n.id];
    html += `<g class="node-group" id="node-${n.id}">`;
    html += `<circle class="node-circle" id="circle-${n.id}" cx="${p.x}" cy="${p.y}"/>`;
    html += `<text class="node-label" id="label-${n.id}" x="${p.x}" y="${p.y}">${n.val}</text>`;
    html += `<text class="node-order" id="order-${n.id}" x="${p.x}" y="${p.y + 35}"></text>`;
    html += `</g>`;
  }

  svg.innerHTML = html;
}

function renderStep(stepIdx) {
  if (stepIdx < 0 || stepIdx >= steps.length) return;
  const step = steps[stepIdx];

  // Update description
  document.getElementById('description').innerHTML = step.desc;

  // Update tree visuals
  for (const n of nodes) {
    const circle = document.getElementById(`circle-${n.id}`);
    const label = document.getElementById(`label-${n.id}`);
    const orderEl = document.getElementById(`order-${n.id}`);

    circle.className.baseVal = 'node-circle';
    label.className.baseVal = 'node-label';
    orderEl.className.baseVal = 'node-order';

    if (step.freed.has(n.id)) {
      circle.classList.add('freed');
      label.classList.add('freed');
      orderEl.textContent = `#${step.freeOrders[n.id]}`;
      orderEl.classList.add('visible');
    }

    if (n.id === step.activeNode && !step.freed.has(n.id)) {
      circle.classList.add('active');
    }
  }

  // Edges
  for (const [from, to] of edges) {
    const el = document.getElementById(`edge-${from}-${to}`);
    el.className.baseVal = 'edge';
    if (step.freed.has(from) || step.freed.has(to)) {
      el.classList.add('freed');
    }
    // Highlight active edge
    if (step.activeNode === to || step.activeNode === from) {
      if (!step.freed.has(from) && !step.freed.has(to)) {
        el.classList.add('active');
      }
    }
  }

  // Update step counter
  document.getElementById('step-counter').textContent = `Step ${stepIdx + 1} / ${steps.length}`;

  // Update log
  if (step.log) {
    const logEl = document.getElementById('log-entries');
    const entry = document.createElement('div');
    entry.className = `log-entry ${step.log.cls}`;
    entry.textContent = step.log.text;
    logEl.appendChild(entry);
    logEl.scrollTop = logEl.scrollHeight;
  }

  // Update call stack
  renderStack(stepIdx);
}

// Rebuild call stack from steps 0..stepIdx
function renderStack(stepIdx) {
  const stackEl = document.getElementById('stack-frames');
  const stack = [];

  for (let i = 0; i <= stepIdx; i++) {
    const s = steps[i];
    if (s.stack_push) {
      stack.push({ text: s.stack_push, type: s.type });
    }
    if (s.stack_pop && stack.length > 0) {
      stack.pop();
    }
  }

  if (stack.length === 0) {
    if (stepIdx >= steps.length - 1) {
      stackEl.innerHTML = '<span class="stack-empty">All calls returned ✓</span>';
    } else {
      stackEl.innerHTML = '<span class="stack-empty">Empty</span>';
    }
    return;
  }

  stackEl.innerHTML = '';
  for (let i = stack.length - 1; i >= 0; i--) {
    const frame = document.createElement('div');
    frame.className = 'stack-frame';
    if (stack[i].type === 'free') frame.classList.add('free-call');
    if (stack[i].type === 'base_case') frame.classList.add('null-call');
    frame.textContent = (i === stack.length - 1 ? '► ' : '  ') + stack[i].text;
    stackEl.appendChild(frame);
  }
}

function nextStep() {
  if (currentStep >= steps.length - 1) return;
  currentStep++;
  renderStep(currentStep);
  updateButtons();
}

function reset() {
  stopAuto();
  currentStep = -1;
  drawTree();
  document.getElementById('description').innerHTML =
    'Press <span class="highlight">Next Step</span> to begin freeing the tree starting from root <span class="val">20</span>. The algorithm visits left subtree → right subtree → then frees the node (post-order).';
  document.getElementById('step-counter').textContent = '';
  document.getElementById('log-entries').innerHTML = '';
  document.getElementById('stack-frames').innerHTML = '<span class="stack-empty">Empty — not started</span>';
  updateButtons();
}

function toggleAuto() {
  if (autoInterval) {
    stopAuto();
  } else {
    const speedVal = document.getElementById('speed').value;
    const ms = [1500, 1000, 700, 450, 250][speedVal - 1];
    document.getElementById('btn-auto').textContent = '⏸ Pause';
    autoInterval = setInterval(() => {
      if (currentStep >= steps.length - 1) {
        stopAuto();
        return;
      }
      nextStep();
    }, ms);
  }
}

function stopAuto() {
  if (autoInterval) clearInterval(autoInterval);
  autoInterval = null;
  document.getElementById('btn-auto').textContent = '▶ Auto Play';
}

function updateButtons() {
  document.getElementById('btn-next').disabled = currentStep >= steps.length - 1;
}

document.getElementById('btn-next').addEventListener('click', nextStep);
document.getElementById('btn-auto').addEventListener('click', toggleAuto);
document.getElementById('btn-reset').addEventListener('click', reset);
document.getElementById('speed').addEventListener('input', () => {
  if (autoInterval) { stopAuto(); toggleAuto(); }
});

drawTree();
</script>

</body>
</html>
